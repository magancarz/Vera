#version 460

#extension GL_EXT_ray_tracing : require

#include "Commons/defines.glsl"

struct Aabb
{
    vec4 minimum;
    vec4 maximum;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct OctreeNode
{
    vec4 children_and_color;
    Aabb aabb;
    uint children_offsets[8];
};

layout(binding = 1, set = 2) buffer Octree { OctreeNode nodes[]; } octree_nodes;

float hitAabb(const Aabb aabb, const Ray r)
{
    vec3 inv_dir = 1.0 / r.direction;
    vec3 t_bot = inv_dir * (aabb.minimum.xyz - r.origin);
    vec3 t_top = inv_dir * (aabb.maximum.xyz - r.origin);
    vec3 t_min = min(t_top, t_bot);
    vec3 t_max = max(t_top, t_bot);
    float t0 = max(t_min.x, max(t_min.y, t_min.z));
    float t1 = min(t_max.x, min(t_max.y, t_max.z));
    return t1 > max(t0, 0.0) ? t0 : T_MAX;
}

#define CHILDREN 4278190080

float hitOctree(const Ray r)
{
    uint stack[32];
    uint stack_ptr = 0;

    stack[stack_ptr++] = 0;

    float hit_t = T_MAX;
    while (stack_ptr > 0)
    {
        OctreeNode octree_node = octree_nodes.nodes[stack[--stack_ptr]];

        float hit_aabb = hitAabb(octree_node.aabb, r);
        if (hit_aabb < hit_t)
        {
            uint children = (uint(octree_node.children_and_color.x) & CHILDREN) >> 24;
            if (children == 0)
            {
                hit_t = min(hit_t, hit_aabb);
                continue;
            }

            for (uint i = 0; i < 8; ++i)
            {
                if ((children & 1 << i) != 0 && hitAabb(octree_nodes.nodes[octree_node.children_offsets[i]].aabb, r) < T_MAX)
                {
                    stack[stack_ptr++] = octree_node.children_offsets[i];
                }
            }
        }
    }

    return hit_t;
}

void main()
{
    Ray ray;
    ray.origin = gl_WorldRayOriginEXT;
    ray.direction = gl_WorldRayDirectionEXT;

    float hit_t = hitOctree(ray);
    if (hit_t < T_MAX)
    {
        reportIntersectionEXT(hit_t, 0);
    }
}